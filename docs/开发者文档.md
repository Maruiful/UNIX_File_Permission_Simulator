# UNIX 文件权限模拟器 - 开发者文档

## 📚 目录

1. [架构设计](#架构设计)
2. [数据结构说明](#数据结构说明)
3. [API 参考](#api-参考)
4. [扩展指南](#扩展指南)
5. [测试指南](#测试指南)
6. [编译和构建](#编译和构建)

---

## 架构设计

### 项目结构

```
UNIX_File_Permission_Simulator/
├── KernProject/              # 内核项目(静态库)
│   ├── file_system.h         # 文件系统接口
│   ├── file_system.c         # 文件系统实现
│   ├── user_manager.h        # 用户管理接口
│   ├── user_manager.c        # 用户管理实现
│   ├── types.h               # 公共类型定义
│   ├── framework.h           # 预编译头设置
│   └── pch.h                 # 预编译头定义
│
├── DemoProject/              # 演示项目(可执行文件)
│   ├── DemoProject.cpp       # 主程序和测试代码
│   └── InteractiveShell      # 交互式Shell实现
│
├── docs/                     # 文档目录
│   ├── 用户手册.md
│   ├── 开发者文档.md
│   └── 测试手册.md
│
└── UNIX_File_Permission_Simulator.slnx  # Visual Studio 解决方案
```

### 双层架构设计

根据课程要求,项目采用严格的**双层架构**:

#### 1️⃣ **内核层 (KernProject)**

**职责**:
- 实现核心数据结构和算法
- 提供文件系统操作接口
- 提供用户管理接口
- **不包含任何 I/O 操作**
- **不使用标准库函数**(除基本的 C 运行时)

**技术限制**:
- ✅ 使用 C 语言(允许 C++ 但不推荐)
- ❌ 禁止 `cin`/`cout`, `printf`/`scanf`
- ❌ 禁止窗口操作
- ❌ 禁止 UI 显示
- ✅ 紧凑、节省空间的数据结构
- ✅ 启用预编译头优化

**输出**: 静态库文件 `KernProject.lib`

#### 2️⃣ **演示层 (DemoProject)**

**职责**:
- 链接 KernProject.lib
- 提供控制台 UI
- 按顺序调用内核函数演示功能
- 使用标准 I/O 进行测试和交互
- 验证内核实现的正确性

**技术自由**:
- ✅ 自由使用 C++ 特性
- ✅ 使用标准 I/O (`iostream`, `printf` 等)
- ✅ 创建测试场景和 UI
- ✅ 完整的错误处理和用户反馈

**输出**: 可执行文件 `DemoProject.exe`

### 模块划分

```
┌─────────────────────────────────────────────────────┐
│                  DemoProject.exe                    │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐│
│  │ 测试代码      │  │ 交互式Shell  │  │   UI层      ││
│  └──────────────┘  └──────────────┘  └─────────────┘│
└─────────────────────────────────────────────────────┘
                       ↕ 链接
┌─────────────────────────────────────────────────────┐
│                  KernProject.lib                    │
│  ┌──────────────┐              ┌──────────────┐    │
│  │  文件系统     │              │  用户管理     │    │
│  │  File System  │              │ User Manager │    │
│  │              │              │              │    │
│  │ • 目录树结构  │              │ • 用户数据   │    │
│  │ • 权限检查    │              │ • 组管理     │    │
│  │ • 路径解析    │              │ • 成员关系   │    │
│  └──────────────┘              └──────────────┘    │
└─────────────────────────────────────────────────────┘
                       ↕ 依赖
┌─────────────────────────────────────────────────────┐
│                   C Runtime Library                 │
└─────────────────────────────────────────────────────┘
```

---

## 数据结构说明

### 文件系统数据结构

#### FileNode (文件节点)

**定义位置**: [`types.h`](KernProject/types.h)

```c
typedef struct FileNode {
    int inode;                  // inode 号(唯一标识)
    char filename[MAX_FILENAME_LEN];  // 文件名
    FileType type;              // 文件类型(目录/普通文件)
    Permissions perms;          // 权限设置
    int uid;                    // 所有者用户ID
    int gid;                    // 所有者组ID
    struct FileNode* parent;    // 父目录指针
    struct FileNode* children;  // 子文件/目录链表头
    struct FileNode* next;      // 同级链表下一个节点
} FileNode;
```

**设计要点**:
- 使用**链表树结构**表示文件系统层次
- 每个节点维护父指针和子节点链表
- 同级节点通过 `next` 指针连接
- 根目录的 `parent` 为 `NULL`, `filename` 为 `""`

**内存布局示例**:
```
        /
        ├── home/
        │   ├── alice/ → file1.txt → file2.txt → NULL
        │   └── bob/ → NULL
        └── tmp/ → NULL
```

#### FileType (文件类型)

```c
typedef enum {
    FILE_TYPE_DIRECTORY = 1,  // 目录
    FILE_TYPE_REGULAR = 2     // 普通文件
} FileType;
```

#### Permissions (权限结构)

```c
typedef struct {
    int owner_perms;   // 所有者权限 (rwx)
    int group_perms;   // 用户组权限 (rwx)
    int other_perms;   // 其他用户权限 (rwx)
} Permissions;
```

**权限位定义**:
```c
#define PERM_READ    4  // 100b - 读权限
#define PERM_WRITE   2  // 010b - 写权限
#define PERM_EXECUTE 1  // 001b - 执行权限
```

**权限组合示例**:
```c
// rwxr-xr-x (755)
perms.owner_perms = PERM_READ | PERM_WRITE | PERM_EXECUTE;  // 7
perms.group_perms = PERM_READ | PERM_EXECUTE;                // 5
perms.other_perms = PERM_READ | PERM_EXECUTE;                // 5
```

### 用户管理数据结构

#### User (用户)

```c
typedef struct {
    int uid;                    // 用户ID
    int gid;                    // 主组ID
    char username[MAX_NAME_LEN]; // 用户名
} User;
```

#### Group (用户组)

```c
typedef struct {
    int gid;                      // 组ID
    char groupname[MAX_NAME_LEN]; // 组名
    int members[MAX_USERS];       // 成员UID数组
    int member_count;             // 成员数量
} Group;
```

**设计要点**:
- 用户和组分别使用**固定大小数组**存储
- `MAX_USERS` 和 `MAX_GROUPS` 定义最大容量
- 组成员使用 UID 数组,不使用指针(简化内存管理)

### 常量定义

```c
#define MAX_FILES          1024    // 最大文件节点数
#define MAX_USERS          256     // 最大用户数
#define MAX_GROUPS         256     // 最大用户组数
#define MAX_FILENAME_LEN   64      // 最大文件名长度
#define MAX_NAME_LEN       32      // 最大用户名/组名长度
#define MAX_PATH_LEN       256     // 最大路径长度
```

---

## API 参考

### 文件系统 API (file_system.h)

#### 初始化和清理

##### `FileSystemStatus fs_init(void)`

**功能**: 初始化文件系统,创建根目录

**返回值**:
- `FS_SUCCESS` - 初始化成功
- `FS_ERR_INVALID` - 参数无效

**示例**:
```c
if (fs_init() == FS_SUCCESS) {
    // 文件系统已就绪
}
```

##### `FileNode* fs_get_root(void)`

**功能**: 获取根目录节点指针

**返回值**: 根目录的 `FileNode*` 指针

---

#### 文件和目录操作

##### `FileSystemStatus fs_create(const char* path, const char* filename, int owner_uid, int owner_gid, Permissions perms, FileType type)`

**功能**: 创建文件或目录

**参数**:
- `path` - 父目录路径(如 `/home`, `/`)
- `filename` - 文件名(如 `test.txt`, `user`)
- `owner_uid` - 所有者用户ID
- `owner_gid` - 所有者组ID
- `perms` - 权限设置
- `type` - 文件类型(`FILE_TYPE_DIRECTORY` 或 `FILE_TYPE_REGULAR`)

**返回值**:
- `FS_SUCCESS` - 创建成功
- `FS_ERR_INVALID` - 参数无效
- `FS_ERR_EXISTS` - 文件已存在
- `FS_ERR_NOT_FOUND` - 父目录不存在
- `FS_ERR_PERMISSION` - 权限不足
- `FS_ERR_LIMIT` - 达到文件数量限制

**示例**:
```c
Permissions perms;
perms.owner_perms = PERM_READ | PERM_WRITE;
perms.group_perms = PERM_READ;
perms.other_perms = PERM_READ;

// 创建文件 /home/test.txt
fs_create("/home", "test.txt", 0, 0, perms, FILE_TYPE_REGULAR);

// 创建目录 /home/user
fs_create("/home", "user", 0, 0, perms, FILE_TYPE_DIRECTORY);
```

##### `FileSystemStatus fs_delete(const char* path)`

**功能**: 删除文件或空目录

**参数**:
- `path` - 完整路径(如 `/home/test.txt`)

**返回值**:
- `FS_SUCCESS` - 删除成功
- `FS_ERR_INVALID` - 参数无效
- `FS_ERR_NOT_FOUND` - 文件不存在
- `FS_ERR_PERMISSION` - 权限不足
- `FS_ERR_NOT_EMPTY` - 目录非空

**注意**: 不能删除根目录

##### `FileSystemStatus fs_delete_recursive(const char* path)`

**功能**: 递归删除文件或目录(包含所有内容)

**参数**:
- `path` - 完整路径

**返回值**:
- `FS_SUCCESS` - 删除成功
- `FS_ERR_INVALID` - 参数无效
- `FS_ERR_NOT_FOUND` - 文件不存在
- `FS_ERR_PERMISSION` - 权限不足

**注意**:
- 不能删除根目录
- 会检查每个子文件/目录的权限

---

#### 文件查找

##### `FileNode* fs_find(const char* path)`

**功能**: 根据绝对路径查找文件节点

**参数**:
- `path` - 绝对路径(必须以 `/` 开头)

**返回值**:
- 成功: 文件节点指针
- 失败: `NULL`

**示例**:
```c
FileNode* node = fs_find("/home/user/file.txt");
if (node != NULL) {
    printf("找到文件: %s\n", node->filename);
}
```

##### `FileNode* fs_find_relative(FileNode* current_dir, const char* path)`

**功能**: 从指定目录开始查找相对路径

**参数**:
- `current_dir` - 当前目录节点
- `path` - 相对路径或绝对路径

**返回值**:
- 成功: 文件节点指针
- 失败: `NULL`

**支持的路径**:
- 绝对路径: `/home/user`
- 相对路径: `user`, `../user`, `./file.txt`
- 混合路径: `../admin/../user/file.txt`

---

#### 文件移动和复制

##### `FileSystemStatus fs_move(const char* src_path, const char* dest_path, int uid, int gid)`

**功能**: 移动文件到不同目录

**参数**:
- `src_path` - 源文件完整路径
- `dest_path` - 目标目录路径(不是完整文件路径)
- `uid` - 执行操作的用户ID
- `gid` - 执行操作的组ID

**返回值**:
- `FS_SUCCESS` - 移动成功
- `FS_ERR_INVALID` - 参数无效
- `FS_ERR_NOT_FOUND` - 源或目标不存在
- `FS_ERR_PERMISSION` - 权限不足
- `FS_ERR_EXISTS` - 目标目录中已有同名文件
- `FS_ERR_NOT_DIR` - 目标不是目录

**权限要求**:
- 源文件的写权限
- 源父目录的写权限
- 目标父目录的写权限

**示例**:
```c
// 将 /home/file.txt 移动到 /home/user/ 目录
fs_move("/home/file.txt", "/home/user", 0, 0);
```

##### `FileSystemStatus fs_copy(const char* src_path, const char* dest_path, int uid, int gid)`

**功能**: 复制文件到指定目录

**参数**: 同 `fs_move`

**返回值**: 同 `fs_move`

**特点**:
- 只复制文件,不复制目录
- 复制的文件所有者是执行复制的用户
- 继承源文件的权限设置

---

#### 文件重命名

##### `FileSystemStatus fs_rename(const char* path, const char* new_name, int uid, int gid)`

**功能**: 重命名文件(在同一目录内)

**参数**:
- `path` - 文件完整路径
- `new_name` - 新文件名
- `uid` - 执行操作的用户ID
- `gid` - 执行操作的组ID

**返回值**:
- `FS_SUCCESS` - 重命名成功
- `FS_ERR_INVALID` - 参数无效
- `FS_ERR_NOT_FOUND` - 文件不存在
- `FS_ERR_PERMISSION` - 权限不足
- `FS_ERR_EXISTS` - 新文件名已存在

**注意**: 不能重命名根目录

---

#### 权限管理

##### `FileSystemStatus fs_chmod(const char* path, Permissions perms)`

**功能**: 修改文件权限

**参数**:
- `path` - 文件路径
- `perms` - 新权限设置

**返回值**:
- `FS_SUCCESS` - 修改成功
- `FS_ERR_INVALID` - 参数无效
- `FS_ERR_NOT_FOUND` - 文件不存在

**注意**:
- Root 可以修改任何文件权限
- 文件所有者可以修改权限
- 其他用户不能修改

##### `PermissionResult fs_check_permission(FileNode* file, int uid, int gid, OperationType op)`

**功能**: 检查用户对文件的操作权限

**参数**:
- `file` - 文件节点指针
- `uid` - 用户ID
- `gid` - 用户组ID
- `op` - 操作类型

**返回值**:
- `PERM_GRANTED` - 权限允许
- `PERM_DENIED` - 权限拒绝

**操作类型**:
```c
typedef enum {
    OP_READ = 1,     // 读操作
    OP_WRITE = 2,    // 写操作
    OP_EXECUTE = 3   // 执行操作
} OperationType;
```

**权限检查逻辑**:
1. 如果 `uid == 0` (root),允许
2. 如果 `uid == file->uid`,检查所有者权限
3. 如果是组成员(`um_is_group_member(file->gid, uid)`),检查组权限
4. 否则检查其他用户权限

---

#### 路径解析

##### `int fs_parse_path(const char* path, char* dirname, char* filename)`

**功能**: 解析路径,分离目录和文件名

**参数**:
- `path` - 完整路径(如 `/home/user/file.txt`)
- `dirname` - 输出:目录部分(如 `/home/user`)
- `filename` - 输出:文件名部分(如 `file.txt`)

**返回值**:
- `0` - 解析成功
- `-1` - 解析失败

**示例**:
```c
char dir[256], name[64];
fs_parse_path("/home/user/file.txt", dir, name);
// dir = "/home/user", name = "file.txt"
```

##### `int fs_normalize_path(const char* input, char* output)`

**功能**: 规范化路径字符串

**参数**:
- `input` - 输入路径(可能包含 `.` 或 `..`)
- `output` - 输出缓冲区(至少 `MAX_PATH_LEN`)

**返回值**:
- `0` - 规范化成功
- `-1` - 规范化失败

**处理**:
- `.` (当前目录)
- `..` (父目录)
- 合并连续的 `/`
- 移除末尾的 `/`(根目录除外)

**示例**:
```c
char output[256];
fs_normalize_path("/home/../user/./file.txt", output);
// output = "/user/file.txt"
```

---

## Shell 命令实现

### 已实现的命令列表

DemoProject 提供了以下交互式 Shell 命令:

#### 用户管理命令

| 命令 | 函数 | 功能 |
|------|------|------|
| `useradd <name>` | `cmd_useradd()` | 创建新用户 |
| `userdel <uid>` | `cmd_userdel()` | 删除用户 |
| `groupadd <name>` | `cmd_groupadd()` | 创建用户组 |
| `groupmod <gid> <uid>` | `cmd_groupmod()` | 添加用户到用户组 |
| `su <uid>` | `cmd_su()` | 切换当前用户 |
| `whoami` | `cmd_whoami()` | 显示当前用户信息 |

#### 文件操作命令

| 命令 | 函数 | 功能 |
|------|------|------|
| `ls [path]` | `cmd_ls()` | 列出目录内容 |
| `mkdir <path>` | `cmd_mkdir()` | 创建目录 |
| `touch <path>` | `cmd_touch()` | 创建文件 |
| `rm <path>` | `cmd_rm()` | 删除文件或空目录 |
| `rm -r <path>` | `cmd_rm()` | 递归删除目录 |
| `mv <src> <dst>` | `cmd_mv()` | 移动/重命名文件 |
| `cp <src> <dst>` | `cmd_cp()` | 复制文件 |

#### 权限管理命令

| 命令 | 函数 | 功能 |
|------|------|------|
| `chmod <path> <perms>` | `cmd_chmod()` | 修改文件权限 |
| `chown <path> <uid> [gid]` | `cmd_chown()` | 修改文件所有者 |

#### 导航命令

| 命令 | 函数 | 功能 |
|------|------|------|
| `cd <path>` | `cmd_cd()` | 切换当前目录 |
| `pwd` | `cmd_pwd()` | 显示当前目录路径 |

#### 其他命令

| 命令 | 函数 | 功能 |
|------|------|------|
| `help` | `cmd_help()` | 显示帮助信息 |
| `exit` | - | 退出 Shell |

### 命令实现规范

所有命令函数遵循以下规范:

1. **参数验证**: 检查必需参数是否提供
2. **权限检查**: 验证当前用户是否有权限执行操作
3. **错误处理**: 提供清晰的错误信息
4. **用户反馈**: 操作成功/失败都有明确提示

**示例**:
```cpp
void cmd_mkdir(const char* path) {
    // 1. 参数验证
    if (path == 0 || str_length(path) == 0) {
        std::cout << "mkdir: 缺少路径参数" << std::endl;
        return;
    }

    // 2. 权限检查(内核层完成)
    // 3. 执行操作
    FileSystemStatus status = fs_create(
        dirname, filename,
        g_current_uid, g_current_gid,
        default_perms, FILE_TYPE_DIRECTORY
    );

    // 4. 用户反馈
    if (status == FS_SUCCESS) {
        std::cout << "目录创建成功" << std::endl;
    } else if (status == FS_ERR_PERMISSION) {
        std::cout << "mkdir: 权限不足" << std::endl;
    }
    // ... 其他错误处理
}
```

---

### 用户管理 API (user_manager.h)

#### 初始化

##### `void um_init(void)`

**功能**: 初始化用户管理系统

**注意**: 使用其他用户管理函数前必须调用

---

#### 用户操作

##### `UserStatus um_create_user(const char* username, int uid, int gid)`

**功能**: 创建新用户

**参数**:
- `username` - 用户名
- `uid` - 用户ID
- `gid` - 主组ID

**返回值**:
- `USER_SUCCESS` - 创建成功
- `USER_ERR_EXISTS` - 用户已存在
- `USER_ERR_INVALID` - 参数无效
- `USER_ERR_LIMIT` - 达到用户数量限制

##### `User* um_find_user_by_uid(int uid)`

**功能**: 根据UID查找用户

**返回值**: 用户指针,未找到返回 `NULL`

##### `User* um_find_user_by_name(const char* username)`

**功能**: 根据用户名查找用户

**返回值**: 用户指针,未找到返回 `NULL`

##### `UserStatus um_delete_user(int uid)`

**功能**: 删除用户

**返回值**:
- `USER_SUCCESS` - 删除成功
- `USER_ERR_NOT_FOUND` - 用户不存在
- `USER_ERR_INVALID` - 参数无效

**注意**: 删除用户不会自动从组中移除

##### `int um_get_user_count(void)`

**功能**: 获取当前用户总数

**返回值**: 用户数量

---

#### 用户组操作

##### `GroupStatus um_create_group(const char* groupname, int gid)`

**功能**: 创建新用户组

**返回值**:
- `GROUP_SUCCESS` - 创建成功
- `GROUP_ERR_EXISTS` - 组已存在
- `GROUP_ERR_INVALID` - 参数无效
- `GROUP_ERR_LIMIT` - 达到组数量限制

##### `Group* um_find_group_by_gid(int gid)`

**功能**: 根据GID查找用户组

**返回值**: 组指针,未找到返回 `NULL`

##### `GroupStatus um_add_group_member(int gid, int uid)`

**功能**: 向组添加成员

**返回值**:
- `GROUP_SUCCESS` - 添加成功
- `GROUP_ERR_NOT_FOUND` - 组不存在
- `GROUP_ERR_INVALID` - 参数无效
- `GROUP_ERR_LIMIT` - 组成员已满

##### `GroupStatus um_remove_group_member(int gid, int uid)`

**功能**: 从组移除成员

**返回值**:
- `GROUP_SUCCESS` - 移除成功
- `GROUP_ERR_NOT_FOUND` - 组或成员不存在
- `GROUP_ERR_INVALID` - 参数无效

##### `int um_is_group_member(int gid, int uid)`

**功能**: 检查用户是否是组成员

**返回值**:
- `1` - 是成员
- `0` - 不是成员

##### `GroupStatus um_delete_group(int gid)`

**功能**: 删除用户组

**返回值**:
- `GROUP_SUCCESS` - 删除成功
- `GROUP_ERR_NOT_FOUND` - 组不存在

---

## 扩展指南

### 添加新的文件系统操作

#### 步骤1: 在 `file_system.h` 中声明函数

```c
/**
 * 新功能描述
 * @param param1 参数1说明
 * @return 返回值说明
 */
FileSystemStatus fs_new_function(const char* param1);
```

#### 步骤2: 在 `file_system.c` 中实现函数

```c
FileSystemStatus fs_new_function(const char* param1) {
    // 1. 参数验证
    if (param1 == 0) return FS_ERR_INVALID;

    // 2. 权限检查
    // PermissionResult perm = fs_check_permission(...);

    // 3. 执行操作
    // ...

    // 4. 返回结果
    return FS_SUCCESS;
}
```

#### 步骤3: 在 DemoProject 中添加测试

```cpp
void test_new_function() {
    std::cout << "测试新功能" << std::endl;

    FileSystemStatus status = fs_new_function("/test");

    if (status == FS_SUCCESS) {
        std::cout << "成功" << std::endl;
    } else {
        std::cout << "失败" << std::endl;
    }
}
```

#### 步骤4: 在 main() 中调用测试

```cpp
int main() {
    // ... 其他测试
    test_new_function();
    return 0;
}
```

---

### 添加新的 Shell 命令

#### 步骤1: 实现命令函数

在 DemoProject.cpp 中添加:

```cpp
void cmd_newcommand(const char* arg1) {
    if (arg1 == 0 || str_length(arg1) == 0) {
        std::cout << "newcommand: 缺少参数" << std::endl;
        return;
    }

    // 权限检查
    // 执行操作
    // 显示结果
}
```

#### 步骤2: 在 `execute_command` 中注册

```cpp
int execute_command(const char* input) {
    // ... 解析命令

    if (str_compare(cmd, "newcommand") == 0) {
        cmd_newcommand(args[0]);
    }
    // ...
}
```

#### 步骤3: 在 `cmd_help` 中添加说明

```cpp
void cmd_help() {
    // ...
    std::cout << "  newcommand <arg>    - 命令说明" << std::endl;
}
```

---

### 扩展数据结构

#### 添加文件属性

如果需要添加文件属性(如创建时间、文件大小):

1. 修改 `FileNode` 结构:

```c
typedef struct FileNode {
    // ... 现有字段
    time_t create_time;      // 创建时间
    long file_size;          // 文件大小
} FileNode;
```

2. 修改 `fs_create` 初始化新字段

3. 更新相关操作(`fs_copy`, `fs_move` 等)

---

### 性能优化建议

#### 1. 使用哈希表加速文件查找

**当前**: 链表查找 O(n)

**优化**: 使用哈希表 O(1)

```c
// 建议数据结构
#define HASH_TABLE_SIZE 256

typedef struct {
    FileNode* table[HASH_TABLE_SIZE];
} FileHashCache;

// 哈希函数
int hash_path(const char* path) {
    int hash = 0;
    while (*path) {
        hash = (hash * 31 + *path) % HASH_TABLE_SIZE;
        path++;
    }
    return hash;
}
```

#### 2. 缓存最近访问的文件

```c
#define CACHE_SIZE 16

typedef struct {
    char* path;
    FileNode* node;
} FileCache;

FileCache recent_files[CACHE_SIZE];
```

#### 3. 减少字符串复制

**当前**: 多次调用 `str_copy`

**优化**: 使用指针引用

---

## 测试指南

### 单元测试结构

DemoProject.cpp 包含的测试:

```
第一阶段: 用户和组管理测试
├── test_basic_user_management()     # 基本用户管理
├── test_basic_group_management()    # 基本用户组管理
├── test_group_membership()           # 组成员管理
└── test_deletion()                   # 删除操作

第二阶段: 文件系统测试
├── test_fs_init()                    # 文件系统初始化
├── test_fs_create()                  # 创建文件和目录
├── test_fs_find()                    # 路径查找
├── test_permission_check()           # 权限检查
├── test_chmod()                      # 修改文件权限
└── test_fs_delete()                  # 删除操作

第三阶段: 文件移动和重命名测试
├── test_rename()                     # 文件重命名
├── test_rename_directory()           # 目录重命名
├── test_move_file()                  # 移动文件
├── test_move_directory()             # 移动目录
├── test_move_rename_permissions()    # 权限限制的移动
├── test_copy()                       # 文件复制
└── test_delete_recursive()           # 递归删除

第三阶段续: 路径解析功能测试
├── test_normalize_path()             # 路径规范化
└── test_find_relative()              # 相对路径查找

任务六: 批量测试脚本
├── test_comprehensive_scenario()     # 多用户协作项目
├── test_multi_user_collaboration()   # 权限继承测试
└── test_edge_cases()                 # 边界条件测试
```

### 运行测试

#### 方式1: 运行所有测试

```bash
1. 编译项目: Ctrl+Shift+B
2. 运行: Ctrl+F5
3. 选择: 1 (运行所有测试)
```

#### 方式2: 运行单个测试

在 `main()` 函数中注释掉其他测试:

```cpp
int main() {
    // 初始化
    um_init();
    fs_init();

    // 只运行一个测试
    test_permission_check();

    return 0;
}
```

#### 方式3: 使用交互式Shell

```bash
1. 运行: Ctrl+F5
2. 选择: 2 (交互式Shell)
3. 手动测试命令
```

### 编写测试用例

#### 测试函数模板

```cpp
void test_your_feature() {
    std::cout << "\n=== 测试: 你的功能 ===" << std::endl;

    // 1. 准备测试数据
    FileSystemStatus status;
    FileNode* node;

    // 2. 执行测试步骤
    std::cout << "步骤1: 描述" << std::endl;
    status = fs_your_function(...);
    std::cout << "  结果: " << (status == FS_SUCCESS ? "成功" : "失败") << std::endl;

    // 3. 验证结果
    node = fs_find("/path/to/file");
    std::cout << "  验证: " << (node ? "找到" : "未找到") << std::endl;

    // 4. 清理测试数据
    fs_delete("/path/to/file");

    std::cout << "✅ 测试完成" << std::endl;
}
```

#### 测试覆盖要点

- ✅ 正常情况(成功路径)
- ✅ 边界情况(空值、最大值)
- ✅ 错误情况(权限不足、文件不存在)
- ✅ 并发情况(多个用户)
- ✅ 清理(测试后恢复环境)

### 调试技巧

#### 1. 使用状态打印

```cpp
void print_fs_status(FileSystemStatus status) {
    switch (status) {
        case FS_SUCCESS:
            std::cout << "成功";
            break;
        case FS_ERR_INVALID:
            std::cout << "失败: 参数无效";
            break;
        // ... 其他情况
    }
    std::cout << std::endl;
}
```

#### 2. 打印文件树

```cpp
void print_file_tree(FileNode* node, int depth) {
    if (node == NULL) return;

    // 缩进
    for (int i = 0; i < depth; i++) std::cout << "  ";

    // 打印节点信息
    std::cout << (node->type == FILE_TYPE_DIRECTORY ? "+" : "-");
    std::cout << " " << node->filename;
    std::cout << " (inode=" << node->inode << ")" << std::endl;

    // 递归打印子节点
    print_file_tree(node->children, depth + 1);
    print_file_tree(node->next, depth);
}
```

#### 3. 验证权限

```cpp
void verify_permission(const char* path, int uid, int gid, OperationType op) {
    FileNode* node = fs_find(path);
    if (node == NULL) {
        std::cout << "文件不存在" << std::endl;
        return;
    }

    PermissionResult result = fs_check_permission(node, uid, gid, op);
    const char* op_str = (op == OP_READ ? "读" : op == OP_WRITE ? "写" : "执行");

    std::cout << "UID=" << uid << " " << op_str << " 权限: ";
    std::cout << (result == PERM_GRANTED ? "允许" : "拒绝") << std::endl;
}
```

---

## 编译和构建

### 开发环境

- **IDE**: Microsoft Visual Studio 2019 或更高版本
- **Platform Toolset**: v145
- **C++ 标准**: C++20 (`stdcpp20`)

### 配置类型

- Debug/Release
- Win32/x64

### 编译步骤

#### 使用 Visual Studio

1. 打开解决方案: `UNIX_File_Permission_Simulator.slnx`
2. 选择配置: Debug/Release, x64
3. 生成: `Ctrl+Shift+B` 或 **生成 > 生成解决方案**

#### 使用 MSBuild 命令行

```bash
# 打开 Visual Studio 开发者命令提示符
cd D:\UNIX_File_Permission_Simulator

# 编译整个解决方案
msbuild UNIX_File_Permission_Simulator.slnx /p:Configuration=Debug /p:Platform=x64

# 只编译内核项目
msbuild KernProject/KernProject.vcxproj /p:Configuration=Debug /p:Platform=x64

# 只编译演示项目
msbuild DemoProject/DemoProject.vcxproj /p:Configuration=Debug /p:Platform=x64
```

### 编译输出

**KernProject (内核)**:
- 输出目录: `x64/Debug/` 或 `x64/Release/`
- 输出文件: `KernProject.lib`

**DemoProject (演示)**:
- 输出目录: `x64/Debug/` 或 `x64/Release/`
- 输出文件: `DemoProject.exe`

### 运行程序

```bash
# 直接运行
x64\Debug\DemoProject.exe

# 或在 Visual Studio 中
Ctrl+F5 (开始执行不调试)
```

### 编译选项

**KernProject**:
- 启用预编译头 (`/Yu`)
- 使用 C 运行时库
- 警告级别: W3

**DemoProject**:
- 使用 C++ 标准库
- UTF-8 编码 (`/utf-8`)
- 控制台子系统

---

## 常见编译问题

### 问题1: 无法找到 KernProject.lib

**解决**:
1. 确保先编译 KernProject
2. 检查 DemoProject 项目属性中的链接器设置
3. 确保库文件路径正确

### 问题2: 中文乱码

**解决**:
1. 确保启用 `/utf-8` 编译选项
2. 在程序开头调用 `SetConsoleOutputCP(65001)`
3. 确保源文件保存为 UTF-8 编码

### 问题3: 链接错误 LNK2019

**解决**:
1. 检查函数声明和实现是否匹配
2. 确认函数已导出(使用 `__declspec(dllexport)` 或 `.def` 文件)
3. 检查调用约定是否一致

---

## 代码风格指南

### 命名规范

- **函数**: 小写+下划线,如 `fs_create`, `um_find_user_by_uid`
- **变量**: 小写+下划线,如 `current_dir`, `file_count`
- **常量**: 全大写+下划线,如 `MAX_FILES`, `PERM_READ`
- **类型**: 大驼峰,如 `FileNode`, `FileSystemStatus`

### 注释规范

```c
/**
 * 函数功能简述
 * @param param1 参数1说明
 * @param param2 参数2说明
 * @return 返回值说明
 * @note 特殊注意事项
 */
ReturnType function_name(Type param1, Type param2) {
    // 实现
}
```

### 缩进和格式

- 使用 4 空格缩进
- 左大括号另起一行(K&R 风格)
- 每行不超过 80 字符

---

## 版本历史

### v1.0 (2026)

- ✅ 基础文件系统功能
- ✅ 用户和组管理
- ✅ 权限控制
- ✅ 路径解析(相对/绝对)
- ✅ 文件移动和复制
- ✅ 递归删除
- ✅ 交互式 Shell (18个命令)
- ✅ 综合测试场景
- ✅ 性能优化(字符串操作、路径解析)
- ✅ 完整的边界检查

---

## 性能优化记录

### 已实现的优化

#### 1. 字符串操作优化 (v1.0)

**优化位置**: `DemoProject/DemoProject.cpp`, `KernProject/file_system.c`

**优化内容**:
- ✅ `get_current_path()`: 从递归改为迭代,减少 67% 的字符串复制
  - 原实现: O(3N) 次字符串复制
  - 优化后: O(N) 次复制,倒序构建路径

- ✅ `fs_normalize_path()`: 使用指针和长度代替字符串复制
  - 原实现: 每个组件需要 `str_copy()` 复制到数组
  - 优化后: 只记录指针和长度,零复制存储
  - 减少 100% 的中间字符串分配

#### 2. 边界检查和安全增强 (v1.0)

**优化位置**: 所有字符串和路径处理函数

**添加的检查**:
- ✅ `str_length()`: 限制最大长度为 `MAX_PATH_LEN * 2`,防止无限循环
- ✅ `str_compare()`: 限制比较长度为 `MAX_PATH_LEN`
- ✅ `str_copy()`: 添加 `max_len` 参数,确保缓冲区安全
- ✅ `str_concat()`: 添加 `max_len` 参数,防止缓冲区溢出
- ✅ `fs_parse_path()`: 添加路径长度、文件名长度、目录长度检查
- ✅ `fs_normalize_path()`: 添加输入长度、组件数量、输出缓冲区边界检查
- ✅ 所有数组访问: 添加边界检查,防止越界访问

**安全性提升**:
- 防止缓冲区溢出攻击
- 防止数组越界访问
- 防止无限循环
- 完整的输入验证

#### 3. Shell 路径处理优化 (v1.0)

**优化位置**: `DemoProject/DemoProject.cpp` - `cmd_mkdir()`, `cmd_touch()`

**优化内容**:
- ✅ 支持相对路径 (`./test`, `../test`)
- ✅ 自动转换为绝对路径后再解析
- ✅ 正确处理路径规范化

---

## 性能基准

### 优化前后对比

| 操作 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| `get_current_path()` (深度N) | 3N 次复制 | N 次复制 | **-67%** |
| `fs_normalize_path()` (N组件) | N 次复制 | 0 次复制 | **-100%** |
| 路径解析安全性 | 无检查 | 完整检查 | **+100%** |

### 内存使用

| 函数 | 优化前 | 优化后 | 减少 |
|------|--------|--------|------|
| `get_current_path()` | 2N 个临时缓冲区 | 1 个缓冲区 | **-50%** |
| `fs_normalize_path()` | N × MAX_FILENAME_LEN | N × (指针+长度) | **-80%** |

---

## 贡献指南

欢迎提交 Issue 和 Pull Request!

### 提交代码前

1. ✅ 运行所有测试,确保通过
2. ✅ 添加相应的测试用例
3. ✅ 更新相关文档
4. ✅ 遵循代码风格指南
5. ✅ 确保无编译警告

---

## 联系方式

- **项目**: UNIX 文件权限模拟器
- **版本**: 1.0
- **文档**: 开发者文档 v1.0

---

**祝开发顺利!** 🚀
